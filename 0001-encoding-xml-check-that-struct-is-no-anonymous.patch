From cca60c1d40ce1a2e99d03d7179d68e671f6a5dbc Mon Sep 17 00:00:00 2001
From: Constantin Konstantinidis <constantinkonstantinidis@gmail.com>
Date: Tue, 21 Aug 2018 12:01:53 +0200
Subject: [PATCH] encoding/xml: check that struct is no anonymous

Fixes #16497

Change-Id: I89f291b818b05e79ae84a21d9cd2f3c535e17dd0
---
 src/encoding/xml/read.go     |  18 +++-
 src/encoding/xml/typeinfo.go |   2 +-
 src/encoding/xml/xml_test.go | 204 +++++++++++++++++++++++++++++++++++
 3 files changed, 220 insertions(+), 4 deletions(-)

diff --git a/src/encoding/xml/read.go b/src/encoding/xml/read.go
index ef5df3f7f6..5d29c7849e 100644
--- a/src/encoding/xml/read.go
+++ b/src/encoding/xml/read.go
@@ -435,9 +435,21 @@ func (d *Decoder) unmarshal(val reflect.Value, start *StartElement) error {
 				}
 				return UnmarshalError(e)
 			}
-			fv := finfo.value(sv, initNilPointers)
-			if _, ok := fv.Interface().(Name); ok {
-				fv.Set(reflect.ValueOf(start.Name))
+			// Anonymous struct with no field or anonymous fields cannot get a value using the reflection
+			// package and must be discarded.
+			anonymousStruct := sv.Type().Name() == "" && sv.Type().Kind() == reflect.Struct
+			if anonymousStruct {
+				i := 0
+				for i < sv.Type().NumField() && anonymousStruct {
+					anonymousStruct = anonymousStruct && sv.Type().Field(i).Anonymous
+					i++
+				}
+			}
+			if !anonymousStruct {
+				fv := finfo.value(sv, initNilPointers)
+				if _, ok := fv.Interface().(Name); ok {
+					fv.Set(reflect.ValueOf(start.Name))
+				}
 			}
 		}
 
diff --git a/src/encoding/xml/typeinfo.go b/src/encoding/xml/typeinfo.go
index f30fe58590..a3ef2bfc9a 100644
--- a/src/encoding/xml/typeinfo.go
+++ b/src/encoding/xml/typeinfo.go
@@ -122,7 +122,7 @@ func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, erro
 	// Parse flags.
 	tokens := strings.Split(tag, ",")
 	if len(tokens) == 1 {
-		finfo.flags = fElement
+		finfo.flags = fElement // Nothing but the name of field
 	} else {
 		tag = tokens[0]
 		for _, flag := range tokens[1:] {
diff --git a/src/encoding/xml/xml_test.go b/src/encoding/xml/xml_test.go
index efddca43e9..563f361b20 100644
--- a/src/encoding/xml/xml_test.go
+++ b/src/encoding/xml/xml_test.go
@@ -857,6 +857,210 @@ func TestIssue12417(t *testing.T) {
 	}
 }
 
+func TestIssue16497(t *testing.T) {
+
+	type IQ struct {
+		Type    string `xml:"type,attr"`
+		XMLName Name   `xml:"iq"`
+	}
+
+	type embedIQ struct {
+		IQ IQ
+	}
+
+	/* Anonymous struct */
+	resp := struct {
+		IQ
+	}{} /* */
+
+	var err error
+	err = Unmarshal([]byte(`<iq/>`), &resp)
+	if err != nil {
+		t.Fatalf("unmarshal anonymous struct failed with %s", err)
+	}
+	// assigning values or not does not change anything
+	var respEmbed embedIQ
+	err = Unmarshal([]byte(`<iq/>`), &respEmbed)
+	if err != nil {
+		t.Fatalf("unmarshal anonymous struct failed with %s", err)
+	}
+}
+
+func TestUnmarshalXMLName(t *testing.T) {
+
+	type InnerStruct struct {
+		XMLName Name `xml:"testns outer"`
+	}
+
+	type OuterStruct struct {
+		InnerStruct
+		IntAttr int `xml:"int,attr"`
+	}
+
+	type OuterNamedStruct struct {
+		InnerStruct
+		IntAttr int  `xml:"int,attr"`
+		XMLName Name `xml:"outerns test"`
+	}
+
+	type OuterNamedOrderedStruct struct {
+		XMLName Name `xml:"outerns test"`
+		InnerStruct
+		IntAttr int `xml:"int,attr"`
+	}
+
+	var unMarshalTestsXMLName = []struct {
+		Value          interface{}
+		ExpectXML      string
+		MarshalOnly    bool
+		MarshalError   string
+		UnmarshalOnly  bool
+		UnmarshalError string
+	}{
+		{
+			ExpectXML: `<outer xmlns="testns" int="10"></outer>`,
+			Value:     &OuterStruct{IntAttr: 10},
+		},
+		{
+			ExpectXML: `<outer xmlns="testns" int="10"></outer>`,
+			Value:     &OuterStruct{IntAttr: 10},
+		},
+		{
+			ExpectXML: `<test xmlns="outerns" int="10"></test>`,
+			Value:     &OuterNamedStruct{XMLName: Name{Space: "outerns", Local: "test"}, IntAttr: 10},
+		},
+		{
+			ExpectXML: `<test xmlns="outerns" int="10"></test>`,
+			Value:     &OuterNamedOrderedStruct{XMLName: Name{Space: "outerns", Local: "test"}, IntAttr: 10},
+		},
+	}
+	for i, test := range unMarshalTestsXMLName {
+		if test.MarshalOnly {
+			continue
+		}
+		if _, ok := test.Value.(*Plain); ok {
+			continue
+		}
+		if test.ExpectXML == `<top>`+
+			`<x><b xmlns="space">b</b>`+
+			`<b xmlns="space1">b1</b></x>`+
+			`</top>` {
+			// TODO(rogpeppe): re-enable this test in
+			// https://go-review.googlesource.com/#/c/5910/
+			continue
+		}
+
+		vt := reflect.TypeOf(test.Value)
+		dest := reflect.New(vt.Elem()).Interface()
+		err := Unmarshal([]byte(test.ExpectXML), dest)
+
+		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
+			switch fix := dest.(type) {
+			case *Feed:
+				fix.Author.InnerXML = ""
+				for i := range fix.Entry {
+					fix.Entry[i].Author.InnerXML = ""
+				}
+			}
+
+			if err != nil {
+				if test.UnmarshalError == "" {
+					t.Errorf("unmarshal(%#v): %s", test.ExpectXML, err)
+					return
+				}
+				if !strings.Contains(err.Error(), test.UnmarshalError) {
+					t.Errorf("unmarshal(%#v): %s, want %q", test.ExpectXML, err, test.UnmarshalError)
+				}
+				return
+			}
+			if got, want := dest, test.Value; !reflect.DeepEqual(got, want) {
+				t.Errorf("unmarshal(%q):\nhave %#v\nwant %#v", test.ExpectXML, got, want)
+			}
+		})
+	}
+}
+
+func TestMarshalXMLName(t *testing.T) {
+
+	type InnerStruct struct {
+		XMLName Name `xml:"testns outer"`
+	}
+
+	type OuterStruct struct {
+		InnerStruct
+		IntAttr int `xml:"int,attr"`
+	}
+
+	type OuterNamedStruct struct {
+		InnerStruct
+		IntAttr int  `xml:"int,attr"`
+		XMLName Name `xml:"outerns test"`
+	}
+
+	type OuterNamedOrderedStruct struct {
+		XMLName Name `xml:"outerns test"`
+		InnerStruct
+		IntAttr int `xml:"int,attr"`
+	}
+
+	var marshalTestsXMLName = []struct {
+		Value          interface{}
+		ExpectXML      string
+		MarshalOnly    bool
+		MarshalError   string
+		UnmarshalOnly  bool
+		UnmarshalError string
+	}{
+		{
+			ExpectXML: `<outer xmlns="testns" int="10"></outer>`,
+			Value:     &OuterStruct{IntAttr: 10},
+		},
+		{
+			ExpectXML: `<outer xmlns="testns" int="10"></outer>`,
+			Value:     &OuterStruct{IntAttr: 10},
+		},
+		{
+			ExpectXML: `<test xmlns="outerns" int="10"></test>`,
+			Value:     &OuterNamedStruct{XMLName: Name{Space: "outerns", Local: "test"}, IntAttr: 10},
+		},
+		{
+			ExpectXML: `<test xmlns="outerns" int="10"></test>`,
+			Value:     &OuterNamedOrderedStruct{XMLName: Name{Space: "outerns", Local: "test"}, IntAttr: 10},
+		},
+	}
+
+	for idx, test := range marshalTestsXMLName {
+		if test.UnmarshalOnly {
+			continue
+		}
+
+		t.Run(fmt.Sprintf("%d", idx), func(t *testing.T) {
+			data, err := Marshal(test.Value)
+			if err != nil {
+				if test.MarshalError == "" {
+					t.Errorf("marshal(%#v): %s", test.Value, err)
+					return
+				}
+				if !strings.Contains(err.Error(), test.MarshalError) {
+					t.Errorf("marshal(%#v): %s, want %q", test.Value, err, test.MarshalError)
+				}
+				return
+			}
+			if test.MarshalError != "" {
+				t.Errorf("Marshal succeeded, want error %q", test.MarshalError)
+				return
+			}
+			if got, want := string(data), test.ExpectXML; got != want {
+				if strings.Contains(want, "\n") {
+					t.Errorf("marshal(%#v):\nHAVE:\n%s\nWANT:\n%s", test.Value, got, want)
+				} else {
+					t.Errorf("marshal(%#v):\nhave %#q\nwant %#q", test.Value, got, want)
+				}
+			}
+		})
+	}
+}
+
 func tokenMap(mapping func(t Token) Token) func(TokenReader) TokenReader {
 	return func(src TokenReader) TokenReader {
 		return mapper{
-- 
2.22.0.windows.1

